#include "Pch.h"
#include "ESPRenderer.h"
#include "XorStr.h"
#include "Fonts.h"
#include "DisplayManager.h"

// Static member initialization
ImDrawList* ESPRenderer::s_drawList = nullptr;
std::map<int, ImFont*> ESPRenderer::s_fonts;
ImFont* ESPRenderer::s_defaultFont = nullptr;
float ESPRenderer::s_screenWidth = 0.0f;
float ESPRenderer::s_screenHeight = 0.0f;
ImVec2 ESPRenderer::s_screenCenter = ImVec2(0.0f, 0.0f);

//const char* fontPath = "C:\\Windows\\Fonts\\verdana.ttf"; // Verdana
const std::vector<int> ESPRenderer::FONT_SIZES = {
    10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22, 24, 26, 28, 30, 40, 50, 60, 70, 80, 90, 100
};

bool ESPRenderer::Initialize()
{
    // 精确字符范围：只包含 zh.h 实际用到的字符，避免图集内存爆炸
    static const ImWchar glyphRanges[] = {
        0x0020, 0x00FF,  // Basic Latin + Latin Supplement
        0x0400, 0x052F,  // Cyrillic
        // CJK - 仅 zh.h 实际使用的字符
        0x4E0A, 0x4E0B, 0x4E0D, 0x4E0D, 0x4E2D, 0x4E2D, 0x4E3A, 0x4E3B,
        0x4E4B, 0x4E4B, 0x4E5F, 0x4E5F, 0x4E8E, 0x4E8E, 0x4EA1, 0x4EA1,
        0x4EBA, 0x4EBA, 0x4EC5, 0x4EC5, 0x4ED6, 0x4ED6, 0x4EE5, 0x4EE5,
        0x4EFB, 0x4EFB, 0x4F1A, 0x4F1A, 0x4F4D, 0x4F4E, 0x4F53, 0x4F53,
        0x4F5C, 0x4F5C, 0x4F7F, 0x4F7F, 0x4F8B, 0x4F8B, 0x4FBF, 0x4FBF,
        0x4FDD, 0x4FDD, 0x503A, 0x503A, 0x503C, 0x503C, 0x504F, 0x504F,
        0x505C, 0x505C, 0x5077, 0x5077, 0x50A8, 0x50A8, 0x50CF, 0x50CF,
        0x5145, 0x5145, 0x5165, 0x5165, 0x5168, 0x5168, 0x5173, 0x5173,
        0x5176, 0x5176, 0x517D, 0x517D, 0x5185, 0x5185, 0x5199, 0x5199,
        0x519B, 0x519B, 0x51B3, 0x51B3, 0x51C6, 0x51C6, 0x51FA, 0x51FB,
        0x5200, 0x5200, 0x5206, 0x5206, 0x5217, 0x5217, 0x5230, 0x5230,
        0x5236, 0x5236, 0x523A, 0x523A, 0x529B, 0x529B, 0x529F, 0x52A0,
        0x52A8, 0x52A8, 0x52FE, 0x52FE, 0x5305, 0x5305, 0x5320, 0x5320,
        0x533B, 0x533B, 0x5355, 0x5355, 0x5357, 0x5357, 0x5370, 0x5370,
        0x5373, 0x5373, 0x53CB, 0x53CC, 0x53D1, 0x53D1, 0x53D6, 0x53D6,
        0x53E0, 0x53E0, 0x53E3, 0x53E3, 0x53EF, 0x53EF, 0x540D, 0x540E,
        0x542F, 0x542F, 0x54C1, 0x54C1, 0x5599, 0x5599, 0x559C, 0x559C,
        0x5668, 0x5668, 0x56FE, 0x56FE, 0x5706, 0x5706, 0x5708, 0x5708,
        0x5728, 0x5728, 0x5730, 0x5730, 0x574F, 0x574F, 0x5757, 0x5757,
        0x578B, 0x578B, 0x5792, 0x5792, 0x586B, 0x586B, 0x58C1, 0x58C1,
        0x58EB, 0x58EB, 0x58F0, 0x58F0, 0x5907, 0x5907, 0x590D, 0x590D,
        0x5927, 0x5927, 0x592B, 0x592B, 0x5934, 0x5934, 0x5939, 0x5939,
        0x5982, 0x5982, 0x59C6, 0x59C6, 0x5B57, 0x5B58, 0x5B63, 0x5B63,
        0x5B98, 0x5B98, 0x5B9A, 0x5B9A, 0x5B9E, 0x5B9E, 0x5BA2, 0x5BA2,
        0x5BB6, 0x5BB6, 0x5BBD, 0x5BBD, 0x5BF9, 0x5BF9, 0x5BFC, 0x5BFC,
        0x5C01, 0x5C01, 0x5C06, 0x5C06, 0x5C0F, 0x5C0F, 0x5C16, 0x5C16,
        0x5C38, 0x5C38, 0x5C42, 0x5C42, 0x5C4F, 0x5C4F, 0x5C5E, 0x5C5E,
        0x5C60, 0x5C60, 0x5DE5, 0x5DE5, 0x5DE7, 0x5DE7, 0x5DF1, 0x5DF1,
        0x5E08, 0x5E08, 0x5E27, 0x5E27, 0x5E38, 0x5E38, 0x5E55, 0x5E55,
        0x5E76, 0x5E76, 0x5E94, 0x5E94, 0x5E9F, 0x5E9F, 0x5EA6, 0x5EA6,
        0x5F00, 0x5F00, 0x5F0F, 0x5F0F, 0x5F29, 0x5F29, 0x5F39, 0x5F39,
        0x5F55, 0x5F55, 0x5F62, 0x5F62, 0x5F71, 0x5F71, 0x5F84, 0x5F84,
        0x5FC3, 0x5FC3, 0x5FD7, 0x5FD7, 0x5FEB, 0x5FEB, 0x6027, 0x6027,
        0x60A8, 0x60A8, 0x60C5, 0x60C5, 0x610F, 0x610F, 0x611F, 0x611F,
        0x620F, 0x6211, 0x6216, 0x6216, 0x6218, 0x6218, 0x6240, 0x6240,
        0x6247, 0x6247, 0x624B, 0x624B, 0x624D, 0x624D, 0x6295, 0x6295,
        0x6297, 0x6297, 0x62A5, 0x62A5, 0x62E9, 0x62E9, 0x6309, 0x6309,
        0x6355, 0x6355, 0x6361, 0x6362, 0x6377, 0x6377, 0x63CF, 0x63CF,
        0x64A4, 0x64A4, 0x6536, 0x6536, 0x6539, 0x6539, 0x653E, 0x653E,
        0x6548, 0x6548, 0x654C, 0x654C, 0x6551, 0x6551, 0x6570, 0x6570,
        0x6587, 0x6587, 0x65B0, 0x65B0, 0x65B9, 0x65B9, 0x65E0, 0x65E0,
        0x65F6, 0x65F6, 0x660E, 0x660E, 0x661F, 0x661F, 0x663E, 0x663E,
        0x666E, 0x666E, 0x6697, 0x6697, 0x66B4, 0x66B4, 0x66F4, 0x66F4,
        0x66FF, 0x6700, 0x6709, 0x6709, 0x672A, 0x672A, 0x672F, 0x672F,
        0x673A, 0x673A, 0x6740, 0x6740, 0x6746, 0x6746, 0x6760, 0x6761,
        0x679C, 0x679C, 0x67AA, 0x67AA, 0x67D3, 0x67D3, 0x6807, 0x6807,
        0x6846, 0x6846, 0x6876, 0x6876, 0x68B0, 0x68B0, 0x68C0, 0x68C0,
        0x6A21, 0x6A21, 0x6A59, 0x6A59, 0x6B3A, 0x6B3A, 0x6B62, 0x6B64,
        0x6B66, 0x6B66, 0x6B7B, 0x6B7B, 0x6B8A, 0x6B8A, 0x6BD2, 0x6BD2,
        0x6BD4, 0x6BD4, 0x6C14, 0x6C14, 0x6CB9, 0x6CB9, 0x6CD5, 0x6CD5,
        0x6D3B, 0x6D3B, 0x6D4B, 0x6D4B, 0x6D77, 0x6D77, 0x6D88, 0x6D88,
        0x6E32, 0x6E32, 0x6E38, 0x6E38, 0x706B, 0x706B, 0x7075, 0x7075,
        0x70B8, 0x70B9, 0x70E7, 0x70E7, 0x718A, 0x718A, 0x71C3, 0x71C3,
        0x7206, 0x7206, 0x7269, 0x7269, 0x7279, 0x7279, 0x72C2, 0x72C2,
        0x72EC, 0x72EC, 0x72F1, 0x72F1, 0x730E, 0x730E, 0x7387, 0x7387,
        0x73A9, 0x73A9, 0x73B0, 0x73B0, 0x7403, 0x7403, 0x74DC, 0x74DC,
        0x751F, 0x751F, 0x7528, 0x7528, 0x754C, 0x754C, 0x754F, 0x754F,
        0x7586, 0x7586, 0x7597, 0x7597, 0x767D, 0x767E, 0x7684, 0x7684,
        0x76AE, 0x76AE, 0x76D6, 0x76D6, 0x76EE, 0x76EE, 0x773C, 0x773C,
        0x7784, 0x7784, 0x77E5, 0x77E5, 0x7834, 0x7834, 0x786E, 0x786E,
        0x793A, 0x793A, 0x79BB, 0x79BB, 0x79C1, 0x79C1, 0x79C3, 0x79C3,
        0x79D1, 0x79D1, 0x79F0, 0x79F0, 0x79FB, 0x79FB, 0x7A33, 0x7A33,
        0x7A7A, 0x7A7A, 0x7A97, 0x7A97, 0x7ACB, 0x7ACB, 0x7AD9, 0x7AD9,
        0x7B49, 0x7B49, 0x7B5D, 0x7B5D, 0x7BAD, 0x7BAD, 0x7BB1, 0x7BB1,
        0x7C73, 0x7C73, 0x7C7B, 0x7C7B, 0x7D20, 0x7D20, 0x7D22, 0x7D22,
        0x7EA2, 0x7EA2, 0x7EBF, 0x7EBF, 0x7ECA, 0x7ECA, 0x7ED8, 0x7ED9,
        0x7F07, 0x7F07, 0x7F29, 0x7F29, 0x7F6E, 0x7F6E, 0x8005, 0x8005,
        0x80BE, 0x80BE, 0x80FD, 0x80FD, 0x8150, 0x8150, 0x817A, 0x817A,
        0x817F, 0x817F, 0x818F, 0x818F, 0x81EA, 0x81EA, 0x8272, 0x8272,
        0x8282, 0x8282, 0x836F, 0x836F, 0x83DC, 0x83DC, 0x84DD, 0x84DD,
        0x85CF, 0x85CF, 0x86C7, 0x86C7, 0x86DB, 0x86DB, 0x8718, 0x8718,
        0x8840, 0x8840, 0x8865, 0x8865, 0x8868, 0x8868, 0x888B, 0x888B,
        0x88AB, 0x88AB, 0x88AD, 0x88AD, 0x8981, 0x8981, 0x8986, 0x8986,
        0x89C6, 0x89C6, 0x89C9, 0x89C9, 0x89D2, 0x89D2, 0x8A00, 0x8A00,
        0x8B66, 0x8B66, 0x8BA1, 0x8BA1, 0x8BA4, 0x8BA4, 0x8BBE, 0x8BBE,
        0x8BED, 0x8BED, 0x8BF1, 0x8BF1, 0x8BF7, 0x8BF7, 0x8C61, 0x8C61,
        0x8D70, 0x8D70, 0x8DB3, 0x8DB3, 0x8DC3, 0x8DC3, 0x8DDD, 0x8DDD,
        0x8EAB, 0x8EAB, 0x8F6C, 0x8F6C, 0x8F7B, 0x8F7B, 0x8F7D, 0x8F7D,
        0x8FA8, 0x8FA8, 0x8FB9, 0x8FB9, 0x8FBE, 0x8FBE, 0x8FDE, 0x8FDE,
        0x9000, 0x9000, 0x9002, 0x9002, 0x9009, 0x9009, 0x900F, 0x900F,
        0x901A, 0x901A, 0x901F, 0x901F, 0x90E8, 0x90E8, 0x914D, 0x914D,
        0x91CD, 0x91CD, 0x91CF, 0x91CF, 0x91D1, 0x91D1, 0x94B1, 0x94B1,
        0x94C1, 0x94C1, 0x94F6, 0x94F6, 0x950B, 0x950B, 0x9524, 0x9524,
        0x952E, 0x952E, 0x955C, 0x955C, 0x95ED, 0x95ED, 0x961F, 0x961F,
        0x9631, 0x9632, 0x9644, 0x9644, 0x9650, 0x9650, 0x9677, 0x9677,
        0x9690, 0x9690, 0x96F7, 0x96F7, 0x9700, 0x9700, 0x9730, 0x9730,
        0x9752, 0x9752, 0x9762, 0x9762, 0x97E7, 0x97E7, 0x9879, 0x9879,
        0x9884, 0x9884, 0x989A, 0x989A, 0x989C, 0x989C, 0x98CE, 0x98CE,
        0x98DF, 0x98DF, 0x9975, 0x9975, 0x9A6E, 0x9A6E, 0x9AA1, 0x9AA1,
        0x9AD8, 0x9AD8, 0x9B3C, 0x9B3C, 0x9C7C, 0x9C7C, 0x9CC4, 0x9CC4,
        0x9E4A, 0x9E4A, 0x9E6B, 0x9E6B, 0x9EC4, 0x9EC4, 0x9ED8, 0x9ED8,
        0,
    };

    ImGuiIO& io = ImGui::GetIO();

    // Init default font (菜单用) - SimHei 内嵌中文字体
    ImFontConfig defaultCfg;
    defaultCfg.FontDataOwnedByAtlas = false;
    defaultCfg.GlyphRanges = glyphRanges;
    s_defaultFont = io.Fonts->AddFontFromMemoryTTF(fontChinese, sizeof(fontChinese), 14.0f * Configs.General.UIScale, &defaultCfg, glyphRanges);
    if (!s_defaultFont) {
        LOG_ERROR("[ESPRenderer] Failed to load default font");
        return false;
    }

    // Load all font sizes (ESP 用)
    for (int size : FONT_SIZES) {
        ImFontConfig cfg;
        cfg.FontDataOwnedByAtlas = false;
        cfg.GlyphRanges = glyphRanges;
        ImFont* font = io.Fonts->AddFontFromMemoryTTF(fontChinese, sizeof(fontChinese), static_cast<float>(size), &cfg, glyphRanges);
        if (font) {
            s_fonts[size] = font;
        }
        else {
            LOG_ERROR("[ESPRenderer] Failed to load font size: %d", size);
        }
    }

    // Atlas build
    bool buildSuccess = io.Fonts->Build();
    if (!buildSuccess) {
        LOG_ERROR("[ESPRenderer] Failed to build font atlas");
        return false;
    }

    LOG_INFO("[ESPRenderer] Successfully initialized with %zu fonts", s_fonts.size());
    return true;
}

void ESPRenderer::BeginFrame()
{
    s_drawList = ImGui::GetBackgroundDrawList();

    // Update screen dimensions if needed
    if (Configs.General.OverrideResolution) {
        s_screenWidth = static_cast<float>(Configs.General.Width);
        s_screenHeight = static_cast<float>(Configs.General.Height);
    }
    else {
        s_screenWidth = DisplayManager::ScreenWidth;
        s_screenHeight = DisplayManager::ScreenHeight;
    }

    s_screenCenter = ImVec2(s_screenWidth * 0.5f, s_screenHeight * 0.5f);
}

void ESPRenderer::DrawText(const ImVec2& pos, const std::string& text, const ImVec4& color, int fontSize, FontAlignment alignment, float outline)
{
    if (!s_drawList) return;

    const ImU32 outlineColor = ImGui::ColorConvertFloat4ToU32(ImVec4(0.05f, 0.05f, 0.05f, color.w));
    ImFont* font = GetFont(fontSize);

    ImVec2 newPos;
    if (alignment == TopLeft)
        newPos = pos;
    else
    {
        ImVec2 textSize = font->CalcTextSizeA(static_cast<float>(fontSize), FLT_MAX, 0.0f, text.c_str());
        switch (alignment)
        {
        case TopLeft:
            newPos = ImVec2(pos.x, pos.y);
            break;
        case TopCenter:
            newPos = ImVec2(pos.x - textSize.x * 0.5f, pos.y);
            break;
        case TopRight:
            newPos = ImVec2(pos.x - textSize.x, pos.y);
            break;
        case MiddleLeft:
            newPos = ImVec2(pos.x, pos.y - textSize.y * 0.5f);
            break;
        case Center:
            newPos = ImVec2(pos.x - textSize.x * 0.5f, pos.y - textSize.y * 0.5f);
            break;
        case MiddleRight:
            newPos = ImVec2(pos.x - textSize.x, pos.y - textSize.y * 0.5f);
            break;
        case BottomLeft:
            newPos = ImVec2(pos.x, pos.y - textSize.y);
            break;
        case BottomCenter:
            newPos = ImVec2(pos.x - textSize.x * 0.5f, pos.y - textSize.y);
            break;
        case BottomRight:
            newPos = ImVec2(pos.x - textSize.x, pos.y - textSize.y);
            break;
        default:
            break;
        }
    }

    if (outline > 0.01f)
    {
        for (int dx = -1; dx <= 1; dx += 1) {
            for (int dy = -1; dy <= 1; dy += 1) {
                if (dx == 0 && dy == 0) continue;
                s_drawList->AddText(font,
                    static_cast<float>(fontSize),
                    ImVec2(newPos.x + (dx * outline), newPos.y + (dy * outline)),
                    outlineColor,
                    text.c_str());
            }
        }
    }

    s_drawList->AddText(font,
        static_cast<float>(fontSize),
        newPos,
        ImGui::ColorConvertFloat4ToU32(color),
        text.c_str());
}

void ESPRenderer::DrawLine(const ImVec2& from, const ImVec2& to, const ImVec4& color, float thickness)
{
    if (!s_drawList) return;
    s_drawList->AddLine(from, to, ImGui::ColorConvertFloat4ToU32(color), thickness);
}

void ESPRenderer::DrawCircle(const ImVec2& center, float radius, const ImVec4& color, float thickness, bool filled)
{
    if (!s_drawList) return;
    if (filled) {
        s_drawList->AddCircleFilled(center, radius, ImGui::ColorConvertFloat4ToU32(color));
    }
    else {
        s_drawList->AddCircle(center, radius, ImGui::ColorConvertFloat4ToU32(color), 0, thickness);
    }
}

void ESPRenderer::DrawRect(const ImVec2& min, const ImVec2& max, const ImVec4& color, float thickness, bool filled)
{
    if (!s_drawList) return;
    if (filled) {
        s_drawList->AddRectFilled(min, max, ImGui::ColorConvertFloat4ToU32(color));
    }
    else {
        s_drawList->AddRect(min, max, ImGui::ColorConvertFloat4ToU32(color), 0.0f, ImDrawFlags_None, thickness);
    }
}

ImFont* ESPRenderer::GetFont(int size)
{
    if (s_fonts.contains(size))
        return s_fonts[size];

    // Fallback font if load failed
    return s_defaultFont;
}